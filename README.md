# INFO 344 PA 2

## Website Link
[Link to working website](http://hw2cloud.cloudapp.net)

## Screenshot
![alt text](https://image.ibb.co/e8SVJm/Capture.jpg "Screenshot of running instance")

## Write up
For this second programming assignment, I spent a bit more time learning the code structure and processes to complete the requirements. I started by researching a Trie and what the data structure itself consists of. This included finding information on the methods that are included in the Trie, as well as the overall structure of the tree. After learning why it’s optimal for searching through millions of entries, I began creating my Trie and Trie Node classes. The Trie Node was fairly easy, and replicated any other tree node that stores a character. The Trie itself on the other hand was complicated to implement. The structure starts by creating a root node with a value of ‘^’, indicating the start of a word. For the insertion function, each character of the input value is placed into the Trie to create a chain of nodes that represent a word. During search, the function takes the input and recursively runs depth first search on the first character and its children until hitting a ‘$’ which represents the end of a word. Once my Trie classes were created, I continued by making a Web Service to interact with. In this web service, there’s a function to access the blob, build the trie, and search the trie. For accessing the blob, the file is downloaded and ready to be used for building. During building, the function downloads the latest version of the file and continues by inserting each word until remaining memory is below 15mb. To track memory usage, I actually had to move my entire project to an Azure Cloud Service and make use of the PerformanceCounter (similar to the example in class). This component let me insert 10,000 words at a time, checking if memory was available on each chunk. After the web service was complete, I moved on to designing the front end where the client would be interacting with the web service. This html file is very barebones and only includes an input bar with search results appearing underneath. Within the file itself, there is included javascript that is meant to sent an ajax request to the web service. On each keystroke within the search input bar, an ajax request is sent to the Search function within the web service, passing in the current input as the parameter. Once something is returned, the first ten results are appended underneath as paragraph tags. The limit on ten results was crucial so searches do not take an extended amount of time to load. Speaking on time, the entire ajax request process takes about 0-4ms to complete based on the input, meaning results are shown almost instantly! To handle the issue of the web service going down, I had to do a lot of research since it wasn’t a straight forward problem. I first began by finding the reason why services go down and discovered Azure allocates space for other running applications once our apps aren’t pinged after certain amount of time. To fix the issue, I approached it by using an online service that would ping my search function within the web service every 5 minutes. This would sent a consistent connection that keeps the application running. For safe measure, I also enabled “Always On” within the Azure dashboard to stop my application from sleeping. I believe with more time dedicated to the issue, I’d be able to find some configuration settings that prevents hibernation but this should do the trick for now!


